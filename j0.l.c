/**
 * @file j0.l.c
 * @author Joseph Coston & Saugat Sharma
 * @brief C code to be imported by j0.l and inserted at the head of the scanner generated by Flex.
 * @version HW6
 *
 */
#include <string.h>
#include <stdlib.h>
#include <stdint.h>

#include "tree.h"
#include "token.h"
#include "j0.tab.h"
#include "errcodes.h"
#include "termargs.h"

void tokenError();
Token *t;
extern char *yyfilename;

/**
 * @brief  Handles the interpretation of sescape sequences
 * @param struct node pointing to the tokens stored in the list
 * @returns void
 */
char handle_escape_sequence(char *str)
{
    int octal = 0;
    if (strncmp(str, "\\n", 2) == 0)
        return '\n';
    else if (strncmp(str, "\\t", 2) == 0)
        return '\t';
    else if (strncmp(str, "\\'", 2) == 0)
        return '\'';
    else if (strncmp(str, "\\\"", 2) == 0)
        return '\"';
    else if (strncmp(str, "\\\\", 2) == 0)
        return '\\';
    else if (strncmp(str, "\\a", 2) == 0)
        return '\a';
    else if (strncmp(str, "\\f", 2) == 0)
        return '\f';
    else if (strncmp(str, "\\r", 2) == 0)
        return '\r';
    else if (strncmp(str, "\\0", 2) == 0)
        return '\0';
    else if ((octal = strtol(str + 1, &str, 8)) != 0)
        return octal;
    else
        PRINTERR("Unrecognized escape code %s\n", str);
    tokenError();
    return -1;
}

/**
 * @brief Converts the passed string's escape sequences into their actual corresponding chars and returns the converted string.
 * @param str string to convert
 * @returns the converted string
 */
char *convert_escape_sequences(char *str)
{
    if (!(str))
    { // confirm that passed string is not NULL
        PRINTERR("ERROR unable to convert empty string. (convert_escape_sequences)\n");
        exit(ERROR_MEMORY);
    }
    int len = strlen(str);                        // get the length of the input string
    char *newStr = calloc(len + 1, sizeof(char)); // allocate memory for the output string
    for (char *s = str; s[0] != 0; s++)           // iterate through the passed string
    {
        char c;
        if (s[0] == '\\')
        {                                  // if the first character in s is \ then attempt to parse an escape sequence code
            c = handle_escape_sequence(s); // this may be assumed to either return a valid escape sequence or cause program exit
            strncat(newStr, &c, 1);        // concatenate the new escape sequence to the converted string
            s++;                           // absorb the extra character in the escape sequence
            len--;                         // decrement the string length since a char was absorbed
            if (s[0] <= '3' && s[0] >= '0')
            {                      // if the escape sequence was an octal code
                char *last = s;    // save the last known value of the string ptr before digit absorbtion
                strtol(s, &s, 8);  // absorb the remaining two octal digit chars (overshoots s next index by 1)
                len -= last - --s; // subtract the extra characters from the length of the result (correcting s)
            }
        }
        else
        { // if the first char is not \ then just append it to the converted string
            strncat(newStr, s, 1);
        }
    }
    char *converted = calloc(len + 1, sizeof(char)); // allocate new space for converted string using final length @free
    strncpy(converted, newStr, len);                 // copy the new string into the converted space
    free(newStr);                                    // free the now old new string
    return converted;
}

/**
 * @brief creates a token for the currently matched string
 * @param token_id the token ID
 * @returns token pointer
 */
int tokenize(int token_id)
{
    yylval.treeptr = (Tree *)malloc(sizeof(Tree));         // @free
    yylval.treeptr->leaf = (Token *)malloc(sizeof(Token)); // @free

    yylval.treeptr->leaf->category = token_id;
    yylval.treeptr->prodrule = token_id;

    yylval.treeptr->leaf->text = (char *)calloc(strlen(yytext) + 1, sizeof(char));
    strcpy(yylval.treeptr->leaf->text, yytext);
    yylval.treeptr->leaf->filename = yyfilename;

    yylval.treeptr->leaf->lineno = yylineno;

    switch (token_id)
    {
    case BOOLLIT:
        yylval.treeptr->leaf->literal.ival = strncmp(yytext, "false", 5) ? 1 : 0; // booleans are stored as int vals
        break;
    case CHARLIT:
        yylval.treeptr->leaf->literal.cval = yytext[1];
        break;
    case INTLIT:
        yylval.treeptr->leaf->literal.ival = atoi(yytext);
        break;
    case LONGLIT:
        yylval.treeptr->leaf->literal.lval = atol(yytext);
        break;
    case FLOATLIT:
        yylval.treeptr->leaf->literal.fval = (float)atof(yytext); // ironically, atof() returns type double, not float
        break;
    case DOUBLELIT:
        yylval.treeptr->leaf->literal.dval = atof(yytext);
        break;
    case STRINGLIT: // must dynamically allocate memory for strings!
        yylval.treeptr->leaf->literal.sval = (char *)calloc(strlen(yytext) + 1, sizeof(char));
        strncpy(yylval.treeptr->leaf->literal.sval, yytext + 1, strlen(yytext) - 2);               // pointer arithmetic to remove quote chars from either end of matched string literal
        yylval.treeptr->leaf->literal.sval = convert_escape_sequences(yylval.treeptr->leaf->literal.sval); // convert the string literal stored to contain its actual escape codes as chars
        PRINTDEBUG("Parsed String literal in %s on line %d: '%s'\n", yyfilename, yylineno, yylval.treeptr->leaf->literal.sval);
        break;
    }
    yylval.treeptr->nkids = 0;
    // print_token(yylval.treeptr->leaf);
    return token_id;
}